---
title: 'Entity Framework Core Migration 深度解密：從 Duplicate Column 錯誤看資料庫版本控制的真相'
description: '從一個真實的 Docker 部署錯誤出發，深入探討 EF Core Migration 的運作機制、實戰應用、回滾陷阱，以及那些官方文檔沒告訴你的殘酷真相'
pubDate: 2025-01-14
author: 'one123'
tags: ['Entity Framework Core', 'Migration', '.NET', 'Database', 'Docker', 'DevOps', 'MariaDB']
category: '技術深度解析'
excerpt: '從一個真實的 Docker 部署錯誤出發，深入探討 EF Core Migration 的運作機制、實戰應用、回滾陷阱，以及那些官方文檔沒告訴你的殘酷真相'
draft: false
---

import { Alert, Card, CodeBlock } from '../../components/MDXComponents.jsx';

## 前言：從一個讓人崩潰的錯誤開始

今天部署羽球論壇系統時，Docker 容器無限重啟，錯誤訊息只有一行：

```
MySqlConnector.MySqlException: Duplicate column name 'DeletedAt'
```

<Alert type="warning">
一個看似簡單的「重複欄位」錯誤，卻暴露了 Migration 管理的深層問題。
</Alert>

這個錯誤背後藏著幾個關鍵問題：為什麼會重複？Migration 歷史為什麼不同步？資料庫版本控制到底該怎麼做？讓我們從這個真實案例開始，揭開 EF Core Migration 的真相。

## 第一章：錯誤現場還原與根因分析

好啦，讓我們從這個讓人崩潰的錯誤開始說起。

### 問題發生經過

在 Docker Compose 環境中，API 容器啟動時會自動執行 `dotnet ef database update`。這次加入軟刪除功能後，容器陷入無限重啟循環。

### 錯誤詳細分析

當我為 `Post` 模型添加軟刪除功能時，生成的 Migration 竟然包含了 `Replies` 表的修改：

```csharp
// Post 模型（新增軟刪除欄位）
public bool IsDeleted { get; set; } = false;
public DateTime? DeletedAt { get; set; }
```

執行 `dotnet ef migrations add` 後，Migration 不只修改了 Posts 表，還嘗試修改 Replies 表。問題是：**Replies 表早就有這些欄位了！**

<Alert type="error">
錯誤原因：資料庫實際狀態與 EF Core Model Snapshot 不同步。
</Alert>

### 問題根因：Migration 歷史不同步

經過一番調查，我發現了一個很尷尬的狀況。

資料庫裡 Replies 表明明就有 `DeletedAt` 欄位了，但 EF Core 的 Model Snapshot 卻說沒有。更扯的是，__EFMigrationsHistory 表也沒有任何相關記錄。結果就是 Migration 傻傻地想再加一次這個欄位，當然就爆「Duplicate column」錯誤了。

### 為什麼會不同步？

通常有幾種可能：

**手動改資料庫**：某個同事覺得「我就加個欄位而已，直接下 SQL 比較快」，結果 EF Core 完全不知道。

**Migration 檔案不見了**：Git 合併的時候出現衝突，某人手一滑就刪掉了。或者根本忘記 commit。

**環境不一致**：開發環境跟測試環境用不同的資料庫，一個有跟上，一個沒跟上。

**團隊太多人改**：小明改 Users 表，小華也改 Users 表，Git 合併後就亂了。

<Card>
**小建議**：遇到不同步的時候不要慌，先看看資料庫現在長什麼樣子，再看看 Migration 認為它該長什麼樣子，找出差異再來修。
</Card>

## 第二章：理解 Migration 的本質

很多人對 Migration 有個天大的誤解，以為它只是拿來「建新資料庫」的工具。錯了！讓我來告訴你 Migration 的真正威力。

### Migration 不只是建立資料庫

許多人誤以為 Migration 只用來「從零建立資料庫」。實際上，它的真正價值在於**增量更新**。

**實際案例**：你的系統已上線，有 10 萬筆用戶資料，現在要加電話號碼欄位。

**沒有 Migration 的真實場景**：

週一早上，你要加個電話號碼欄位...

**Step 1**：花 30 分鐘寫 SQL 文檔，還要截圖說明  
**Step 2**：群發訊息「大家記得跑 SQL 喔！」然後開始追人  
**Step 3**：開 Excel 記錄 - 小明跑了、小華忘了、小李說等一下...  
**Step 4**：自己手動登入 4 個環境，一個一個複製貼上 SQL  
**Step 5**：如果有 100 個客戶？恭喜你，要做 100 次一樣的事  
**Step 6**：凌晨 2 點，第 67 個客戶執行失敗...現在怎麼辦？

**有 Migration（自動化管理）**：
```bash
dotnet ef migrations add AddPhoneNumber  # 創建更新
dotnet ef database update                 # 自動執行
```

Migration 會自動檢測當前版本、只執行需要的更新、記錄執行歷史，還支援回滾（雖然有限制）。

### Migration 的三大核心組件

<Card>
**Migration 的三大元件**：
1. **Migration 檔案** - 記錄每次要改什麼
2. **Model Snapshot** - 現在資料庫該長什麼樣子
3. **__EFMigrationsHistory** - 資料庫記錄已經做了哪些事
</Card>

這三個傢伙要是不同步，就會出現我們開頭遇到的「Duplicate column」錯誤。想想看，一個說有、一個說沒有，當然會打架啊！

### Migration 執行流程

當你執行 `dotnet ef database update` 時，背後其實發生了一連串精密的動作。

EF Core 會先去讀 __EFMigrationsHistory 表，看看哪些 Migration 已經跑過了。接著比對一下，找出那些還沒執行的。然後按照時間戳順序，一個一個執行 Up 方法。最後記錄下來，確保下次不會重複執行。

整個過程完全自動化，你只需要下一個指令就好。

<Alert type="info">
**重點**：EF Core 會自動判斷哪些 Migration 需要執行，不會重複執行已完成的。
</Alert>

### 資料遷移的藝術

這裡要說 Migration 最厲害的地方了 - 它不只能改結構，還能同時幫你轉換資料。你知道這有多重要嗎？

**常見資料遷移場景：**

**1. 分割姓名欄位**
```csharp
// 將 FullName 分割成 FirstName + LastName
migrationBuilder.Sql(@"
    UPDATE Users 
    SET FirstName = SUBSTRING_INDEX(FullName, ' ', 1),
        LastName = SUBSTRING_INDEX(FullName, ' ', -1)
");
```

**2. 貨幣單位轉換** 
```csharp  
// 從分轉換成元
migrationBuilder.Sql("UPDATE Products SET Price = PriceInCents / 100.0");
```

**3. 數據歸一化**
```csharp
// 統一電話格式
migrationBuilder.Sql(@"
    UPDATE Users 
    SET PhoneNumber = REGEXP_REPLACE(PhoneNumber, '[^0-9]', '')
");
```

<Alert type="warning">
**重要提醒**：資料遷移前一定要備份，特別是生產環境！
</Alert>

### 為什麼不能每次都創建空 Migration？

很多人想說：「乾脆每次都建空的 Migration，就不會出錯了吧？」

這想法聽起來不錯，但實際上會造成大災難。想想看，你的系統已經有 10 萬筆用戶資料了，如果每次都從零開始建資料庫，這些資料要怎麼辦？總不能叫用戶重新註冊吧？

而且你也會失去所有變更記錄。三個月後老闆問你：「上次改的會員等級系統是什麼時候上線的？」你只能攤手說不知道，因為根本沒有歷史記錄。

最麻煩的是，當你需要把舊資料轉換成新格式時（比如把價格從台幣轉美金），空 Migration 完全幫不上忙。你得自己寫一堆 SQL 去處理，然後祈禱不要出錯。

<Card>
💡 **記住**：空 Migration 就像是把房子拆掉重蓋，看起來乾淨，但你會失去所有的傢俱和回憶。只有在 Migration 檔案全部遺失的緊急情況下才該這麼做。
</Card>

## 第三章：實戰案例 - 真實世界的 Migration 應用

講了這麼多理論，來看看實際案例吧。這些都是血淋淋的經驗教訓。

### 案例 1：生產環境更新 - 加入用戶等級系統

**需求**：在已有 10 萬用戶的系統加入等級、經驗值、徽章功能。

#### 😱 沒有 Migration 的噩夢

**手動編寫 SQL 文檔**：

```sql
-- 必須按順序執行 20+ 個 SQL 指令
-- 每個環境都要手動執行
-- 出錯了要怎麼回滾？
```

**實際發生的災難**：

**凌晨 2 點** - 維運人員開始執行 SQL
**2:05** - 出現「Duplicate column」錯誤
**2:10** - 發現一半的表已經存在，現在進退兩難
**2:30** - 資料庫狀態不明，不敢繼續也不敢回滾
**3:00** - 緊急打電話給所有開發人員
**6:00** - 大家還在修復中，用戶已經在客訴了...

**多環境的惡夢**：

生產環境在 1.9.2 版，測試環境是 1.9.0 版，開發環境已經跑到 2.0.0 版了。

每個環境要執行不同的 SQL，你得記住誰是誰，然後一個一個手動更新。光是想就頭痛。

#### 有 Migration 的優雅解決

```bash
# 一個命令搞定所有環境
dotnet ef database update

# Migration 會自動：
# ✅ 檢測當前版本
# ✅ 只執行需要的更新  
# ✅ 記錄執行歷史
# ✅ 失敗可回滾
```

**實際效果**：5 分鐘完成所有環境更新，零錯誤率，維運人員終於可以安心睡覺了。

### 案例 2：多租戶 SaaS 系統 - 100 個客戶的挑戰

**情境**：你的 SaaS 系統有 100 個客戶，每個客戶都有獨立的資料庫，現在要幫所有客戶同步升級新功能。

#### 手動管理的惡夢

想像一下，你得手動登入 100 個不同的資料庫，一個一個執行 SQL 更新...

**實際發生的慘況**：
- 30 個客戶：更新成功（耶！）
- 20 個客戶：更新到一半出錯，現在不知道哪些表已更新、哪些還沒更新
- 50 個客戶：完全失敗，資料庫結構亂掉了

結果呢？整個週末都在加班修復，星期一還要面對 70 個憤怒的客戶投訴。

#### Migration 自動化解決

```bash
# 一個命令更新所有客戶
dotnet migrate-all-tenants

執行結果：
100 個客戶全部成功，總共只花了 5 分鐘。
因為是並行執行，速度快了 20 倍，還會自動產生報告。
```

**Migration 的優勢**：自動偵測版本差異、智能執行需要的更新、失敗可重試，還有完整的執行日誌。

### 案例 3：5 人團隊協作 - 同步的挑戰

想像一下，你們團隊有 5 個人，小明負責用戶認證、小華負責標籤系統、小美負責通知功能、小強負責搜尋功能、小李負責報表系統。

#### 沒有 Migration 的混亂

**Slack 真實對話**：

```
小明 [09:30]：大家注意！我加了幾個欄位，請執行 SQL...
小華 [10:15]：我也改了，記得執行...
小美 [10:30]：等等，我昨天就加了！
小李 [11:30]：完蛋，我剛 DROP 了 Tags 表...
小華 [11:31]：我的資料！！！

結果：資料庫不同步、資料遺失、團隊效率降低 80%。
```

#### 有 Migration 的和諧協作

```bash
# 每個人都用 Migration
git pull
dotnet ef migrations add MyFeature
git push

# 其他人同步
git pull  
dotnet ef database update
# 自動應用所有變更！
```

**結果**：零衝突、完整追蹤、即時同步。大家都很開心。

<Card>
**小秘訣**：Migration 會按照時間戳順序執行，所以即使大家同時改同一個表也不會打架。Git 合併的時候記得把所有 Migration 檔案都留著就好。
</Card>

## 第四章：Migration 回滾的真相

好，現在要說一個很多人不知道的殘酷真相 - Migration 回滾會讓你的資料消失！

### 重要警告：資料確實會消失！

<Alert type="error">
**回滾 = 資料遺失**。這不是 bug，是設計如此。
</Alert>

### 實際案例：付費功能回滾

你原本有 1000 位付費用戶、5000 筆交易記錄、3 個月的營收數據。結果執行回滾後呢？
```sql
DROP TABLE PaymentHistory;  -- 所有交易記錄消失
DROP COLUMN IsPremium;      -- 付費狀態消失
```

**結果**：所有資料徹底消失，無法回復！客戶的交易記錄不見了，你說怎麼辦？

### 回滾的正確使用時機

**什麼時候可以安全回滾？**

1. **開發/測試環境** - 資料不重要，階時可以重建
2. **剛執行的 Migration** - 剛剛上線 5 分鐘，還沒有新資料進來
3. **只是結構變更** - 只是加個空表，還沒寫資料

<Alert type="warning">
**經驗法則**：生產環境上線超過 1 小時，就不要回滾了！
</Alert>

### 正確做法：向前修正（Forward Fix）

**錯誤做法：直接回滾**
```bash
dotnet ef database update PreviousMigration
# 後果：所有付費資料消失 → 客戶投訴 → 賠償
```

**方法 1：功能開關**
```json
// appsettings.json
{
  "Features": {
    "Premium": {
      "Enabled": false  // 緊急關閉，資料保留
    }
  }
}
```

**方法 2：資料保留修正**
```csharp
// 新 Migration，不是回滾
migrationBuilder.AddColumn<bool>("TemporarilyDisabled");
// 暫時停用，但保留所有資料
```

**方法 3：版本化**
```csharp
// 保留 v1，新增 v2
migrationBuilder.AddColumn<bool>("IsPremiumV2");
// 逐步遷移，確認穩定後才刪除 v1
```

<Card>
**黃金法則**：生產環境永遠「向前修正」，不要回滾！記住，資料比什麼都重要。
</Card>


## 第五章：Migration 遺失的救援方案

如果你不幸遇到 Migration 檔案全部不見的狀況，先別慌！我們還有救。

### 快速評估

先冷靜下來，確認幾件事：資料庫還在嗎？有備份嗎？是生產環境的資料嗎？知道現在的資料庫結構嗎？

### 方案 1：反向工程

如果資料庫還在，可以從資料庫反向生成模型：

```bash
# 從資料庫生成模型
dotnet ef dbcontext scaffold "連線字串" 提供者
```

優點是快速，缺點是你會失去所有 Migration 歷史。

### 方案 2：空 Migration（推薦）

步驟很簡單：先暫時清空 DbContext，創建一個空的 Migration，然後恢復 DbContext，最後手動插入歷史記錄。

```sql
INSERT INTO __EFMigrationsHistory 
VALUES ('20250814_InitialCreate', '8.0.10');
```

<Alert type="info">
這是最安全的方法，不會影響現有資料！
</Alert>


### 生產環境救援 SOP

如果是生產環境，請依照這個步驟。首先備份資料庫（這是最重要的！），接著導出現在的結構、創建空 Migration 讓 EF Core 知道現狀、插入歷史記錄來同步，最後驗證同步狀態確認一切正常。

<Card>
**重要提醒**：生產環境操作前一定要備份！一定要備份！一定要備份！（很重要所以說三次）
</Card>

## 最佳實踐總結

### 1. 版本控制

```bash
# .gitignore
# ❌ 絕不要加：
# /Migrations  
```

### 2. 命名規範

好的命名像是 AddUserAuthenticationFields、CreateOrderTables、RefactorProductPricing，一看就知道在幹嘛。

不好的命名像是 Update1（看不出在更新什麼）、Fix（修什麼？）、Changes（改了什麼？），這種命名三個月後你自己都看不懂。

### 3. 審查流程

每次 PR 有 Migration 時，記得檢查幾件事：有沒有 Down 方法？回滾會不會遺失資料？需不需要先備份？會影響多少資料？

### 4. 自動備份

```bash
# 每次 Migration 前自動備份
mysqldump > backup_$(date +%Y%m%d).sql
```

### 5. 監控檢查

養成每天檢查的習慣：
- 有沒有未執行的 Migration？
- 歷史表是否完整？
- 模型跟資料庫有沒有同步？

## 結語

回到最初的問題：為什麼需要 Migration？

<Card>
**答案**：因為真實世界的軟體需要演進，而不是重建。就像你不會每次裝修房子都把它拆掉重蓋一樣。
</Card>

Migration 就像資料庫的 Git。Git 追蹤程式碼變化，Migration 追蹤資料庫變化。

### Migration 的核心價值

Migration 給你的是可追溯性，你知道資料庫怎麼一步步變成現在這樣。它能可重現，在任何環境都能重建一模一樣的結構。團隊可協作，成員不用再問「你改了什麼？」。可以自動化，CI/CD 直接跑，不用人工介入。還能回滾，雖然有風險，但至少有這個選項。

### 最終建議

擁抱 Migration，它是最佳實踐。理解它的限制，知道何時不該回滾。建立團隊規範，確保流程一致。最重要的是持續學習，經驗需要累積。

從我的 Duplicate Column 錯誤經驗看，問題往往不是 Migration 本身，而是我們沒有正確使用它。

<Alert type="success">
**記住**：Migration 不是銀彈，但是我們目前擁有的最好工具。用好它，資料庫管理之路會順暢許多。
</Alert>

---

<Alert type="info">
本文基於真實的開發經驗撰寫，所有案例都來自實際專案。如果你也遇到類似的問題，希望這篇文章能幫助你更好地理解和使用 Entity Framework Core Migration。
</Alert>