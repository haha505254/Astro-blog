---
title: 'Astro 無限滾動除錯實錄：當靜態遇上動態，一場架構選擇的挑戰'
description: '從無限滾動重複載入的表象，深入探究 Astro SSG 與 SSR 的本質差異。這不是程式碼的錯，而是架構理解的盲點'
pubDate: 2025-08-14
author: 'Lin'
category: '技術筆記'
tags: ['Astro', '無限滾動', 'SSG', 'SSR', 'API Routes', '除錯經驗', 'Hybrid Mode']
excerpt: '花了數小時修改參數解析邏輯，最後發現問題根本不在程式碼。當 API 永遠返回第一頁時，真相藏在 Astro 的渲染模式裡'
draft: false
---

import { Alert, Card } from '../../components/MDXComponents.jsx';

## 序章：一個看似簡單的需求

「我不想用分頁，現在不是流行往下滑會自動加載嗎？」

就是這麼一個簡單的需求，開啟了一場長達數小時的除錯之旅。從 `/blog/1` 到無限滾動，理論上應該很簡單：建立 API、實作 Intersection Observer、搞定。

但當第二頁載入的內容和第一頁一模一樣時，我知道事情沒那麼簡單。

## 第一章：症狀浮現 - 無限滾動的無限重複

### 初始實作

創建了一個標準的 API 端點：

```typescript
// src/pages/api/posts.json.ts
export const GET: APIRoute = async ({ url }) => {
  const page = url.searchParams.get('page');
  const limit = url.searchParams.get('limit');
  
  // 分頁邏輯
  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + limit;
  const paginatedPosts = posts.slice(startIndex, endIndex);
  
  return new Response(JSON.stringify({
    posts: paginatedPosts,
    currentPage: page,
    hasMore: endIndex < posts.length
  }));
};
```

React 組件使用 Intersection Observer：

```tsx
// InfiniteScrollBlog.tsx
const loadPosts = async () => {
  const response = await fetch(`/api/posts.json?page=${page}&limit=6`);
  const data = await response.json();
  setPosts(prev => [...prev, ...data.posts]);
};
```

### 詭異的現象

當滾動到底部時：
- ✅ API 被正確呼叫
- ✅ 網路請求顯示 `?page=2&limit=6`
- ❌ 返回的卻是第一頁的內容
- ❌ `currentPage` 永遠是 1

<Alert type="warning">
症狀：明明請求第二頁，API 卻總是返回第一頁的資料
</Alert>

## 第二章：錯誤的除錯方向 - 在參數解析上繞圈

### 嘗試 1：改變參數獲取方式

```typescript
// 嘗試各種方式獲取參數
const pageParam = url.searchParams.get('page');
const page = pageParam ? parseInt(pageParam) : 1;

// 改成
const page = parseInt(url.searchParams.get('page') || '1');

// 再改成
const page = Number(url.searchParams.get('page')) || 1;
```

**結果**：全部失敗，`pageParam` 永遠是 `null`

### 嘗試 2：使用 request 物件

```typescript
export const GET: APIRoute = async ({ request }) => {
  const url = new URL(request.url);
  const page = url.searchParams.get('page');
  console.log('Request URL:', request.url);
  // 輸出：http://localhost:4321/api/posts.json（沒有參數！）
};
```

**結果**：URL 中根本沒有查詢參數

### 嘗試 3：Context 參數實驗

```typescript
export const GET: APIRoute = async (context) => {
  // 嘗試從 context 的各種屬性獲取
  const url = new URL(context.request.url);
  const params = context.url.searchParams;
  // ...各種組合
};
```

**結果**：徒勞無功

### 除錯日誌的困惑

```bash
# curl 測試
curl "http://localhost:4321/api/posts.json?page=2&limit=6"

# 服務器日誌
API Params: { pageParam: null, limitParam: null, page: 1, limit: 6 }
Request URL: http://localhost:4321/api/posts.json  # 參數消失了！
```

## 第三章：真相大白 - SSG vs SSR 的本質差異

### 關鍵發現

查閱 Astro 文檔後發現了關鍵資訊：

<Card>
**Astro 默認是靜態站點生成器（SSG）**

在構建時，所有頁面和 API 路由都會被預渲染成靜態文件。這意味著 API 路由在構建時就已經執行，而不是在請求時執行。
</Card>

### 問題的根源

```javascript
// astro.config.mjs - 默認配置
export default defineConfig({
  // output: 'static', // 這是默認值，通常不寫
  integrations: [...]
});
```

在 `static` 模式下：
1. `npm run build` 時，Astro 會執行 API 路由
2. 生成靜態的 JSON 文件（如 `/api/posts.json`）
3. 運行時只是提供靜態文件，不執行任何程式碼
4. 查詢參數被完全忽略

### 為什麼開發環境也有問題？

即使在 `npm run dev` 下，Astro 也會模擬生產環境的行為，預渲染 API 路由以保持一致性。

## 第四章：正確的解決方案 - 新的 Static 模式

### Astro v5 的重大變更

根據官方文檔，Astro v5.0 將 `output: 'hybrid'` 與 `output: 'static'` 合併成新的 `'static'` 模式。新的 `static` 模式現在包含了之前 `hybrid` 的所有功能。

```javascript
// astro.config.mjs
export default defineConfig({
  output: 'static', // 新的 static 已包含 hybrid 功能
  adapter: netlify(), // 需要適配器處理動態路由
  site: 'https://your-site.com',
  integrations: [mdx(), sitemap(), react(), tailwind()],
});
```

<Alert type="success">
重要發現：Astro v5 不再有獨立的 `hybrid` 模式，功能已整合到新的 `static` 模式中！
</Alert>

## 第五章：官方推薦的實作方式

### 步驟 1：使用新的 Static 模式

```javascript
// astro.config.mjs
export default defineConfig({
  output: 'static', // 使用新的 static 模式
  site: 'https://your-site.com',
  integrations: [mdx(), sitemap(), react(), tailwind()],
});
```

### 步驟 2：安裝並配置適配器（處理動態路由）

```bash
# 安裝 Netlify 適配器（根據你的部署平台選擇）
npm install @astrojs/netlify
```

```javascript
// astro.config.mjs
import netlify from '@astrojs/netlify';

export default defineConfig({
  output: 'server',
  adapter: netlify(), // 必須添加適配器！
  site: 'https://your-site.com',
  integrations: [mdx(), sitemap(), react(), tailwind()],
});
```

### 步驟 3：設置動態路由

在新的 `static` 模式下，頁面默認是預渲染的。只需要將 API 路由設為動態：

```typescript
// src/pages/api/posts.json.ts
export const prerender = false; // API 路由設為動態執行

// src/pages/blog/[...slug].astro
// 不需要設置，默認就是預渲染

// src/pages/blog/[page].astro  
// 不需要設置，默認就是預渲染
```

### 最終驗證

```bash
# API 支持動態參數
curl "http://localhost:4321/api/posts.json?page=2&limit=6"
{
  "currentPage": 2,    # ✅ 正確
  "posts": [...],      # ✅ 第二頁內容
  "hasMore": false
}

# 文章頁面正常顯示
http://localhost:4321/blog/your-article/  # ✅ 內容完整顯示
```

## 第六章：Astro 輸出模式的真相

### 1. Static（默認）

```javascript
output: 'static' // 或不設置
```

- **特點**：所有內容在構建時生成
- **部署**：可部署到任何靜態主機（GitHub Pages、Netlify、Vercel）
- **性能**：最快，純靜態文件
- **限制**：無法處理動態請求、無法使用查詢參數

### 2. Server（全動態）

```javascript
output: 'server'
```

- **特點**：所有請求都在服務器端處理
- **部署**：需要 Node.js 運行環境
- **性能**：較慢，每次請求都要處理
- **優勢**：完全動態，支持所有服務器功能

### 3. Static v5（新的混合模式）

```javascript
output: 'static' // v5 的 static 已包含 hybrid 功能
adapter: netlify() // 需要適配器處理動態路由

// 在需要動態的頁面加上：
export const prerender = false
```

- **特點**：默認靜態，可選擇性設置動態
- **優勢**：官方推薦的做法，性能最佳
- **部署**：需要適配器支持動態路由（Netlify、Vercel 等）

<Alert type="success">
**實戰結論**：Astro v5 的新 `static` 模式已包含所有 hybrid 功能，這是官方推薦的最佳實踐
</Alert>

## 第七章：部署考量

### Netlify 部署配置

```toml
# netlify.toml
[build]
  command = "npm run build"
  publish = "dist"

[functions]
  directory = "netlify/functions"
```

### Vercel 部署配置

```json
// vercel.json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist"
}
```

兩個平台都完美支持 Astro 的 Hybrid 模式，會自動識別並部署服務器端功能。

## 經驗總結：架構理解勝過程式碼技巧

### 學到的教訓

1. **先確認架構限制**：不要急著改程式碼，先理解框架的運作模式
2. **讀文檔很重要**：Astro 文檔清楚說明了三種輸出模式的差異
3. **開發環境會騙人**：開發環境可能模擬生產環境的限制
4. **調試要看本質**：參數為 null 不是解析問題，是根本沒收到參數

### 時間成本分析

- ❌ 在錯誤方向上除錯（參數解析）：3 小時
- ❌ 嘗試使用已移除的 Hybrid 模式：30 分鐘
- ❌ 誤用 Server 模式作為替代方案：40 分鐘
- ✅ 正確使用新的 Static 模式：15 分鐘

### 適用場景建議（更新版）

| 場景 | 建議模式 | 原因 |
|------|---------|------|
| 純展示部落格 | Static (v5) | 最佳性能，易部署 |
| 需要搜尋、評論 | Static (v5) + prerender=false | 官方推薦的混合方案 |
| 社交平台、論壇 | Server | 高度動態互動 |
| 混合內容網站 | Static (v5) + 適配器 | 默認靜態，選擇性動態 |

## 結語：這不是 Bug，是 Feature

Astro 的靜態優先設計不是缺陷，而是深思熟慮的架構選擇。它確保了：

1. **默認最佳性能**：靜態文件永遠最快
2. **漸進式增強**：需要時才使用動態功能
3. **明確的性能成本**：動態功能需要明確選擇

這次除錯經歷提醒我們：**理解工具的設計哲學，比熟記 API 更重要**。當你知道「為什麼」時，「怎麼做」就變得顯而易見。

下次當 API 不接收參數時，不要急著改程式碼，先問問自己：**這個 API 是靜態的還是動態的？**

<Alert type="success">
**最終成果**：無限滾動完美運作，初始載入 6 篇，滾動載入剩餘 3 篇，沒有重複，體驗流暢。
</Alert>

---

*除錯時間：2025年8月14日凌晨*  
*框架版本：Astro 5.12.2*  
*初始嘗試：Static → Hybrid 模式（失敗）*  
*官方方案：Static (v5) + 選擇性動態渲染*  
*關鍵發現：Astro v5 將 hybrid 功能整合進新的 static 模式*