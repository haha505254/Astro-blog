---
title: 一個開發者的 OAuth 踩坑實錄：從 403 Forbidden 到柳暗花明
description: 記錄整合 Google OAuth 登入功能時遇到的 403 錯誤，以及 GCP 設定和前端實作的完整除錯過程
pubDate: 2025-08-07
author: Lin
tags: ['OAuth', 'Google Cloud', 'Vue', '.NET', '身份驗證', '除錯經驗', 'GCP']
category: 技術筆記
excerpt: 當程式碼寫對了卻還是 403 Forbidden 時，問題往往不在程式碼本身。這是一個關於雲端設定、API 混用，以及最終找到標準作業流程的故事
draft: false
---

## 📝 前言

今天，在為我的「羽球論壇」專案整合 Google 登入功能時，我撞上了一面紅色的高牆。

前端的程式碼看起來無懈可擊，後端的 API 端點也準備就緒，Client ID 也設定好了。但每當我滿懷期待地按下登入按鈕，瀏覽器的主控台（Console）卻無情地噴出 `403 Forbidden` 的錯誤。

Google 就像一個不近人情的保全，直接把我的應用程式拒之門外。

<br />

---

<br />

## 🔴 一切的開端：一個名為「403 Forbidden」的紅色警告

### 🤔 發生了什麼？

我的程式碼（Vue 元件、.NET API）就像是精心準備的通行口令，我以為只要口令對了，大門就會為我敞開。但我錯了，錯得離譜。

罪魁禍首，竟然不是程式碼本身，而是遠在天邊的 Google Cloud Platform (GCP) 後台，那些我以為「大概設定一下就好」的選項。

<br />

### 💡 學到的第一課：程式碼寫對了，不代表門就會開

在整合第三方服務時，我們的應用程式只是個「訪客」。真正控制大門的，是遠端服務的「配置中心」。

在 Google OAuth 的世界裡，GCP Console 就是那位至高無上的「守門人」。你沒有按照它的規矩，精確地登記你的身份和來源，它根本不會聽你說什麼。

<br />

---

<br />

## 🌅 柳暗花明：原來我需要的是一張「雲端通行證」

在我幾乎要放棄，準備自己手刻一個登入表單時，我才意識到問題的本質：我需要停止猜測，回過頭去仔細閱讀「訪客須知」——也就是 GCP 的設定文件。

我需要的不是更多的程式碼，而是一張經過官方認證、完美無瑕的「雲端通行證」。

<br />

### 💡 學到的第二課：不要自己管理憑證，讓專業的來

GCP Console 就像是我們應用程式的「外交部」。我們不再需要自己去處理繁瑣的驗證細節，只需要告訴這位「外交官」：

- 「我的應用程式叫『羽球論壇』！」 → 設定同意畫面
- 「我的開發基地在 localhost:5173！」 → 設定授權的 JavaScript 來源
- 「我的正式大使館在 my-forum.com！」 → 再次設定授權來源
- 「這是我的官方印章，請幫我註冊！」 → 建立 OAuth 2.0 憑證

從此，身份驗證的流程變得清晰可見，所有設定都有源可溯，乾淨又安全。

<br />

---

<br />

## 🔧 動手改造：申請我的官方「雲端通行證」

下定決心後，我開始了我的憑證申請計畫。

### 1. 建立專案總部
在 GCP 建立一個名為 `BadmintonForumProject` 的專案，並綁定結算帳戶，完成身份驗證。

### 2. 設計迎賓海報
設定「OAuth 同意畫面」，類型選「外部」，並填上 **羽球論壇** 的名稱，讓使用者知道是誰在請求授權。

### 3. 刻印官方鑰匙 (Client ID)
這一步是成敗的關鍵：

在「憑證」頁面建立「OAuth 用戶端 ID」。

在「已授權的 JavaScript 來源」這個門禁卡白名單中，我學到了血的教訓，必須一字不差地加入所有可能的開發來源，且結尾不能有斜線：

```
http://localhost:5173
http://127.0.0.1:5173  (localhost 的另一個名字，必加！)
```

最後，將產生的 Client ID 像寶貝一樣複製下來。

<br />

---

<br />

## 🐇 深入兔子洞：前端的「九彎十八拐」實作迷宮

正當我以為 GCP 設定好就天下太平時，前端又出事了。登入按鈕時好時壞，控制台出現了看不懂的 FedCM 警告，甚至還混用了兩種不同的 Google API。

<br />

### 💡 學到的第三課：不要混用兩種不同的鑰匙！

我之前的程式碼，像個糊塗的鎖匠，試圖用 `google.accounts.id` (用來拿身分證 ID Token 的鑰匙) 和 `google.accounts.oauth2` (用來拿通行證 Access Token 的鑰匙) 去開同一扇門。

這兩種 API 的用途完全不同，混用只會導致混亂和失敗。

<br />

### 💡 學到的第四課：官方的永遠最香！

在經歷了 One Tap 失敗、手動觸發彈窗等各種複雜的嘗試後，我發現最可靠、最簡單的方法，竟然是 Google 一開始就推薦的：

```javascript
google.accounts.id.renderButton()
```

這等於是告訴 Google：「嘿，按鈕給你做，流程給你管，我什麼都不想操心，你辦完事後把『數位身分證 (ID Token)』給我就好。」

這不僅解決了所有 FedCM 的相容性問題，還讓我的程式碼瞬間乾淨了好幾倍。

<br />

---

<br />

## 🎯 終極解密：我得到的不是登入功能，是可信賴的「SOP」！

今天從一個小小的 403 錯誤開始，最終不僅讓 Google 登入穩定運行，還徹底搞懂了整個 OAuth 2.0 的配置精髓和前端實作的最佳實踐。

我得到的不是一個新功能，而是一套未來可以應用在任何專案上，穩定、可靠、安全的標準作業流程 (SOP)。

從此，面對第三方登入，再也不用懷疑人生。